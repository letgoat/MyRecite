1. 在main函数之前和之后执行的代码可能是什么  
1) 之前：  
- 栈
- 

2) 之后：  

2. 结构体内存对齐问题  
3. 指针和引用的区别  
- 实质  
- 多级，一级  
- NULL  
- 改变指向  
- sizeof  
- 传参  
- 汇编层面  
- 声明和定义  
- 指向空  

4. 传参过程中，什么时候使用指针，什么时候使用引用？  
- 返回函数内局部变量的内存  
- 栈空间  
- 类对象？  

5. 堆和栈的区别  
- 申请方式  
- 申请大小  
- 申请效率  

6. 你觉得堆快一点还是栈快一点  
- 操作系统  
- C/C++库  

7. 区别以下指针类型  
int *p[10]  
int (*p)[10]  
int *p(int)  
int (*p)(int)  

8. new/delete与malloc/free的异同  
相同点：  

不同点：  
- 实质  
- 计算分配空间大小  
- 安全否  
- 调用  
- 库文件支持  

9. new和delete是如何实现的？  
- 内存  
- 构造  
- 指针  

10. malloc和new的区别？  
- 实质  
- 构造
- 返回类型  

11. 既然有了malloc/free，C++为什么还需要new/delete？直接用malloc/free不好吗？  
- 都有用  
- malloc和free是库函数  




22. C++中struct和class的区别  
相同点：  
- 成分  
- 功能  

不同点：  
- 成员 默认  
- 继承 默认  

23. define宏定义和const的区别  
- 编译阶段  
- 安全性  
- 内存占用  

24. C++中const和static的作用  
static:
- 不考虑类的情况  
    - 隐藏  
    - 默认初始化为0  
    - 静态变量在函数内的特性  
- 考虑类的情况  
    - static成员变量  
        - 只与类关联  
        - 初始化  
        - 被任意非static成员函数访问  
    - static成员函数  
        - 不具备this指针  
        - 不能访问非static的成员变量和函数  
        - 不能被声明为const，虚函数和volatile  
        - 被任意非static成员函数任意访问  

const：
- 不考虑类的情况
    - const常量定义时必须初始化  
    - const形参接收  
- 考虑类的情况  
    - const成员变量  
        - 不能类定义外部初始化，只能构造函数初始化列表进行初始化，必须要有构造函数  
        - 不同类对其const数据成员可以不同，因此不能在类中声明时初始化  
    - const成员函数  
        - const对象不可以调用非const成员函数，非const对象都可以调用
        - 不可以改变非mutable数据的值  

25. C++的顶层const和底层const  
概念区分：
    - 顶层const: 指的是const修饰的变量本身是一个常量   int* const b1 = &a  
    - 底层const: 指的是const修饰的变量指向的对象是一个常量  const int* b2 = &c  
区分作用：  
    - 对象拷贝存在限制
    - const_cast只能改变底层const  
    - int const a 和 const int a均表示定义常量类型a  

26. 数组名和指针（这里的指针为数组首元素的指针）区别？  
    - 二者均可通过增减偏移量来访问数组中的元素  
    - 数组名不是真正意义上的指针，可以理解成常指针，所以数组名没有自增，自减等操作  
    - 当数组名当做形参传递给函数后，就退化成一般的指针，多了自增自减操作；但sizeof得不到原来数组的大小了  

27. final 和 override关键字  

28. 拷贝初始化和直接初始化  
    - 用于类类型对象时  
        - 直接初始化：直接调用与实参匹配的构造函数  
        - 拷贝初始化： 先使用指定构造函数创建一个临时对象，然后使用拷贝构造函数将临时对象拷贝到正在创建的那个对象  

29. 初始化和赋值的区别  
    - 简单类型，初始化和赋值没有什么区别  
    - 对于类和复杂数据类型  

30. extern"C"的用法  
    - C++代码中调用C语言代码  
    - 在C++头文件中使用  
    - 多人协同开发时，有人擅长C语言，有人擅长C++  

31. 野指针和悬空指针  
    - 野指针：没有初始化过的指针  
    - 悬空指针：最初指向的内存已经被释放的一种指针  

32. C和C++的类型安全  

33. C++中的重载，重写和隐藏的区别  
    - 1. 重载(overlaod)  
    - 2. 重写（override）
    - 3. 隐藏（hide）：派生类中的函数屏蔽了基类中的同名函数，包括以下情况：
        - 两个函数参数相同，但是基类函数不是虚函数  
        - 两个函数参数不同，无论基类函数是不是虚函数都会被隐藏  

34. C++中有哪几种的构造函数  
    - 1. 默认构造函数  
    - 2. 初始化构造函数（有参数）
    - 3. 拷贝构造函数  
    - 4. 移动构造函数  （move和右值引用）  
    - 5. 委托构造函数  
    - 6. 转换构造函数  

35. 深拷贝和浅拷贝的区别  
    - 浅拷贝：只拷贝一个指针，没有开辟新的地址；原来指针所指向的资源释放后，指针就会悬空  
    - 深拷贝：不仅拷贝值，还开辟一块新空间存放新拷贝的对象  

36. 内联函数和宏定义的区别  
    - 1. 在使用时，宏只做简单字符串替换（编译前），而内联函数可以进行参数类型检查（编译时），且具有返回值  
    - 2. 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，省去返回值，可以实现重载  
    - 3. 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义  

38. 如何用代码判断大小端存储  
    - 1. 大端存储：字数据的高字节存储在低地址  
    - 2. 小段存储：字数据的低字节存储在低地址  
    在socket编程中，往往需要将系统所用的小端存储的IP地址转换成大端存储，这样才能进行网络传输  

39. Volatile、mutable和explicit关键词的用法  
    - 1. volatile: 用volatile声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统，硬件或者其他线程  
        对于volatile声明的变量，系统总重新从它所在的内存读取数据  
        volatile的变量是易变的，每次用到这个变量的值的时候都要重新读取这个值，而不是读取寄存器的备份。多线程中被几个任务共享的变量需要定义为volatile  
        
40. 什么是右值引用（Rvalue reference）？  
200. C++从编写到可执行的过程  
    1） 编写代码
    2） 预处理：处理头文件 宏替换 条件编译 去除注释 添加行号  
    3） 编译：将预处理后的代码编译成汇编语言  
    4） 汇编：将汇编语言编译成机器语言  
    5） 连接：将多个目标文件链接成一个可执行文件  

201. 什么是C++中的auto和decltype  

202. 请介绍C++多态的实现原理  
虚函数  
虚函数表：函数指针数组，包含该类所有虚函数的地址  
虚函数表指针：虚表指针存储在对象实例中，指向属于该对象的虚表  

203. 为什么new[]和delete[]一定要配对使用？  
    1）内存泄漏  
    2） 运行时错误  

204. malloc申请的内存，可以用delete释放吗？  
不能
    1）malloc是C标准库函数，delete是C++的内存管理机制，实现原理不同  
    2）malloc只申请内存，不调用构造函数  
    3）