1. 在main函数之前和之后执行的代码可能是什么  
1) 之前：  
- 栈
- 

2) 之后：  

2. 结构体内存对齐问题  
3. 指针和引用的区别  
- 实质  
- 多级，一级  
- NULL  
- 改变指向  
- sizeof  
- 传参  
- 汇编层面  
- 声明和定义  
- 指向空  

4. 传参过程中，什么时候使用指针，什么时候使用引用？  
- 返回函数内局部变量的内存  
- 栈空间  
- 类对象？  

5. 堆和栈的区别  
- 申请方式  
- 申请大小  
- 申请效率  

6. 你觉得堆快一点还是栈快一点  
- 操作系统  
- C/C++库  

7. 区别以下指针类型  
int *p[10]  
int (*p)[10]  
int *p(int)  
int (*p)(int)  

8. new/delete与malloc/free的异同  
相同点：  

不同点：  
- 实质  
- 计算分配空间大小  
- 安全否  
- 调用  
- 库文件支持  

9. new和delete是如何实现的？  
- 内存  
- 构造  
- 指针  

10. malloc和new的区别？  
- 实质  
- 构造
- 返回类型  

11. 既然有了malloc/free，C++为什么还需要new/delete？直接用malloc/free不好吗？  
- 都有用  
- malloc和free是库函数  




22. C++中struct和class的区别  
相同点：  
- 成分  
- 功能  

不同点：  
- 成员 默认  
- 继承 默认  

23. define宏定义和const的区别  
- 编译阶段  
- 安全性  
- 内存占用  

24. C++中const和static的作用  
static:
- 不考虑类的情况  
    - 隐藏  
    - 默认初始化为0  
    - 静态变量在函数内的特性  
- 考虑类的情况  
    - static成员变量  
        - 只与类关联  
        - 初始化  
        - 被任意非static成员函数访问  
    - static成员函数  
        - 不具备this指针  
        - 不能访问非static的成员变量和函数  
        - 不能被声明为const，虚函数和volatile  
        - 被任意非static成员函数任意访问  

const：
- 不考虑类的情况
    - const常量定义时必须初始化  
    - const形参接收  
- 考虑类的情况  
    - const成员变量  
        - 不能类定义外部初始化，只能构造函数初始化列表进行初始化，必须要有构造函数  
        - 不同类对其const数据成员可以不同，因此不能在类中声明时初始化  
    - const成员函数  
        - const对象不可以调用非const成员函数，非const对象都可以调用
        - 不可以改变非mutable数据的值  

25. C++的顶层const和底层const  
概念区分：
    - 顶层const: 指的是const修饰的变量本身是一个常量   int* const b1 = &a  
    - 底层const: 指的是const修饰的变量指向的对象是一个常量  const int* b2 = &c  
区分作用：  
    - 对象拷贝存在限制
    - const_cast只能改变底层const  
    - int const a 和 const int a均表示定义常量类型a  

26. 数组名和指针（这里的指针为数组首元素的指针）区别？  
    - 二者均可通过增减偏移量来访问数组中的元素  
    - 数组名不是真正意义上的指针，可以理解成常指针，所以数组名没有自增，自减等操作  
    - 当数组名当做形参传递给函数后，就退化成一般的指针，多了自增自减操作；但sizeof得不到原来数组的大小了  

27. final 和 override关键字  

28. 拷贝初始化和直接初始化  
    - 用于类类型对象时  
        - 直接初始化：直接调用与实参匹配的构造函数  
        - 拷贝初始化： 先使用指定构造函数创建一个临时对象，然后使用拷贝构造函数将临时对象拷贝到正在创建的那个对象  

29. 初始化和赋值的区别  
    - 简单类型，初始化和赋值没有什么区别  
    - 对于类和复杂数据类型  

30. extern"C"的用法  
    - C++代码中调用C语言代码  
    - 在C++头文件中使用  
    - 多人协同开发时，有人擅长C语言，有人擅长C++  

31. 野指针和悬空指针  
    - 野指针：没有初始化过的指针  
    - 悬空指针：最初指向的内存已经被释放的一种指针  

32. C和C++的类型安全  

33. C++中的重载，重写和隐藏的区别  
    - 1. 重载(overlaod)  
    - 2. 重写（override）
    - 3. 隐藏（hide）：派生类中的函数屏蔽了基类中的同名函数，包括以下情况：
        - 两个函数参数相同，但是基类函数不是虚函数  
        - 两个函数参数不同，无论基类函数是不是虚函数都会被隐藏  

34. C++中有哪几种的构造函数  
    - 1. 默认构造函数  
    - 2. 初始化构造函数（有参数）
    - 3. 拷贝构造函数  
    - 4. 移动构造函数  （move和右值引用）  
    - 5. 委托构造函数  
    - 6. 转换构造函数  

35. 深拷贝和浅拷贝的区别  
    - 浅拷贝：只拷贝一个指针，没有开辟新的地址；原来指针所指向的资源释放后，指针就会悬空  
    - 深拷贝：不仅拷贝值，还开辟一块新空间存放新拷贝的对象  

36. 内联函数和宏定义的区别  
    - 1. 在使用时，宏只做简单字符串替换（编译前），而内联函数可以进行参数类型检查（编译时），且具有返回值  
    - 2. 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，省去返回值，可以实现重载  
    - 3. 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义  

38. 如何用代码判断大小端存储  
    - 1. 大端存储：字数据的高字节存储在低地址  
    - 2. 小段存储：字数据的低字节存储在低地址  
    在socket编程中，往往需要将系统所用的小端存储的IP地址转换成大端存储，这样才能进行网络传输  

39. Volatile、mutable和explicit关键词的用法  
    - 1. volatile: 用volatile声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统，硬件或者其他线程  
        对于volatile声明的变量，系统总重新从它所在的内存读取数据  
        volatile的变量是易变的，每次用到这个变量的值的时候都要重新读取这个值，而不是读取寄存器的备份。多线程中被几个任务共享的变量需要定义为volatile(避免编译器将变量从内存中装到CPU寄存器中)  
    
    - 2. mutable: mutable是为了突破const的限制而设置的，被mutable修饰的变量将永远处于可变的状态  

    - 3. explicit: explicit用来修饰类的构造函数，被修饰的类不能发生相应的隐式类型转换，只能用显示的方式进行类型转换  

41. C++有哪几种类型的new  
三种：plain new, nothrow new, placement new  
    - 1. plain new: 简而言之就是普通的new, 在空间分配失败后，抛出std::bad_alloc而不是返回NULL  
    - 2. nothrow new: nothrow new在空间分配失败的情况下，不抛出异常，而是返回NULL  
    - 3. placement new: 这种new允许在一块已经分配成功的内存上重新构造对象或者对象数组；
        placement new根本不用担心分配空间失败，因为他只调用构造函数，需要注意两点：
            - placement new的主要用途就是反复分配一块较大的动态内存来构造不同类型的对象或者他们的数组  
            - placement new构造的对象数组，要显示调用他们的析构函数来销毁，不能用delete。  

42. C++的异常处理的方法：  
    - 1. try、throw和catch关键字  
    - 2. 函数的异常声明列表
    - 3. C++标准异常类exception  
        - bad_typeid
        - bad_cast  
        - bad_alloc  
        - out_of_range  

47. 静态变量什么时候初始化  
    - 初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存  
    - 静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存  
    - 

48. 从汇编层去解释一下引用  

53. delete p、delete []p、 allocator都有什么作用？  
    - new动态数组返回的并不是数组类型，而是一个元素类型的指针  
    - delete[]时，数组中的元素按逆序的顺序进行销毁  
    - allocator将new的功能分开，allocator负责申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作  

57. malloc、realloc、calloc的区别？  
    -malloc：   int *p = malloc(20*sizeof(int)) //分配20个int类型的空间  
    -calloc：   int *p = calloc(20, sizeof(int));
    省去了人为空间计算，malloc申请的空间的值是随机初始化，calloc申请的空间的值是初始化为0的  
    -realloc:   给动态分配的空间分配额外的空间，用于扩充容量  

60. C++新增了string, 它与C语言中的char* 有什么区别吗？它是如何实现的？  
    string 继承子basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等属性值  
    string 可以实现动态扩容，每次扩展的时候，另外申请一块原空间大小两倍的空间(2*n), 然后将原字符串拷贝过去，并且加上新增的内容  


61. 什么是内存泄漏，如何检测和避免  
    内存泄漏： 一般指堆内存的泄漏  
    避免内存泄漏的几种方式：
        - 1. 计数法：使用new或者malloc时，让该数+1，delete或者free时，让该数-1。 当程序执行完，打印这个计数，如果不为0，则表示存在内存泄漏  
        - 2. 一定要将基类的析构函数声明为虚函数  
        - 3. 对象数组的释放一定要用delete[]  
        - 4. 有new 就有 delete, 有malloc 就有 free，保证配对出现。  
    检测工具：
        Linux: Valgrind工具  
        Windows: CRT库  

62. 对象复用的了解，零拷贝的了解  
    对象复用： 本质是一种设计模式--Flyweight享元模式  
    通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源  

    零拷贝： 零拷贝就是一种避免CPU将数据从一块存储拷贝到另一块存储的技术  
            零拷贝技术可以减少数据拷贝和共享总线操作的次数  
            

200. C++从编写到可执行的过程  
    1） 编写代码
    2） 预处理：处理头文件 宏替换 条件编译 去除注释 添加行号  
    3） 编译：将预处理后的代码编译成汇编语言  
    4） 汇编：将汇编语言编译成机器语言  
    5） 连接：将多个目标文件链接成一个可执行文件  

201. 什么是C++中的auto和decltype  

202. 请介绍C++多态的实现原理  
虚函数  
虚函数表：函数指针数组，包含该类所有虚函数的地址  
虚函数表指针：虚表指针存储在对象实例中，指向属于该对象的虚表  

203. 为什么new[]和delete[]一定要配对使用？  
    1）内存泄漏  
    2） 运行时错误  

204. malloc申请的内存，可以用delete释放吗？  
不能
    1）malloc是C标准库函数，delete是C++的内存管理机制，实现原理不同  
    2）malloc只申请内存，不调用构造函数  
    3）